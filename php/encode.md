## 编码转换引发的一次血案

### 1 事件缘由

在一次进行现网发布后，导致用户在前端无法拉起密码框。经过问题定位，发现是由于发布时，文件的编码进行了修改，原本是GBK的，修改成了UTF-8，然而，CGI在处理配置文件时，将它作为GBK处理的，会将配置文件先转换成UTF-8，由于已经是UTF-8的，转换函数在进行编码转换时会导致中文截断。

### 2 问题根源

问题在于，发布平台对用户的配置文件的编码进行了转换。用户在前台进行配置文件编辑时，要经过文件的读出和写入过程。为了在前端正确的展示，在读出时，将读出的文件内容的编码转换成了UTF-8，然而，在写入到文件时，是直接写入的，而没有将要写入的内容的编码转换成原文件的编码，从而造成配置文件的编码变成UTF-8。

### 3 问题的解决

#### 3.1 文件的读出

PHP中读取文件可以使用三种方式：

* file($filename)。读取文件，并将文件内容放到数组中，一行就是数组的一个元素。当需要对每一行进行处理时，该函数比较方便。
* fread($filename, $length)。最多读取文件中$length个字节，也可以处理二进制文件。
* file_get_contents($filename)。读取文件，返回字符串。

因为是需要读取整个文件，因此不使用file()。另外，当一个文本文件很大时，也不适合在前台进行编辑，因此，在读取时，需要设置要读取的字节数，因此，这里使用fread()限定读取的字节数。

在读取文件时，为了在前台正常地展示给用户看，需要将读取的内容的编码转换成UTF-8，转换之前还需要知道原编码是什么，因此，需要检测文件的原编码。

PHP中mb_detect_encoding()可以检测字符串的编码，然后再用iconv()或者mb_convert_encoding()转换。

也可以采用下面的方式检测文件的编码：

```PHP
// 检测文件的编码
private function check_file_encode($path) {
    $content = file_get_contents($path);
    $encodes = array('ASCII', 'GBK', 'UTF-8');
    foreach($encodes as $encode) {
        // 如果字符串可以采用某个编码为过渡再次转换成原编码
        // 就说明该字符串是该编码
        if ($content === mb_convert_encoding(mb_convert_encoding($content, "UTF-32", $encode), $encode, "UTF-32")) {
            return $encode;
        }
    }

    return false;
}
```

#### 3.2 文件的写入

写入时，为了保持与原编码的一致，还是需要在写入前检测文件的编码，然后将要写入的字符串进行转码，然后再写入文件。

### 4 小结

文件编码从来都是个难题，这次也算是吸取了一次教训吧！

* 对文件进行操作时，尽量不要修改文件的属性。例如，这里的编码，又例如，在拷贝文件时，有时候需要保持文件的属性(最后修改时间、属主等)。
* 在平时开发时，考虑问题还是要尽量周全，把工作做足，在遇到紧急问题时，才不会束手无策。读取文件时，进行了转码，写入文件时，就不需要吗？
* 从问题本身看，这次的问题也是无法避免的，当各种"巧合"在一起时，就会发生难以预料的问题。