### 2016年8月23日

#### 1 使用xargs操作多个文件时，结果的格式问题

使用正则表达式在目录中查找某个模式，采用了xargs grep进行，得到的结果类似如下：

```
file1:matched_text
file2:matched_text
```

然后，使用程序对该结果进行分析，得到每个文件中的所有的匹配模式。

然而，当文件只有一个时，却有问题，得到的结果却是：

```
matched_text
```

对多个文件操作时，结果中带了匹配的文本所在的文件，而对单个文件操作时，却没有携带文件名。

是什么造成了这种差异呢？是xargs还是grep本身呢？

xargs只是依次用后面的命令处理输入的参数，因此，这种结果应该是grep本身产生的。通过对grep的帮助文档的查看，找到了对应的说明：

> -H, --with-filename

> Print the file name for each match. This is the default when there is more than one file to search

> -h, --no-filename

> Suppress the prefixing of file names on output. This is the default when there is only one file (or only standard input) to search

grep的默认行为是：当操作的文件只有一个时，结果中不包含文件名；当操作的文件不止一个，对每个匹配添加文件名。

因此，给grep命令添加`-H`选项可以解决该问题。

---

### 2016年8月25日

#### 2 kill发送信号时，TERM和KILL的区别

在脚本中调用另一个停止进程的脚本，结果超时了(超时时间为10分钟)。手动执行脚本，很快就正常结束了。

然后，阅读停止进程的脚本，发现它采用如下的方式停止脚本：

* 查看PID文件是否存在，如果存在，则直接读取PID，如果不存在，则根据执行进程的命令获取PID。
* 给进程发送TERM信号
* 然后循环等待进程退出，每过1秒查看进程是否存活，直到进程退出为止。

但是，之前在脚本中调用该停止脚本时超时，也许这里会产生死循环？

然后再次手动执行，结果这次没有正常结束，也就是说，脚本的执行存在一定的概率性。

发现让进程停止的命令是`kill -TERM $pid`，而我们常用的进程停止命令是`kill -9 $pid`，TERM与9是什么关系呢？

通过查阅发现：

* -9表示-KILL，强制杀死进程。
* -TERM，给进程发送停止信号，并准备回收进程的结束状态，但是，进程是否停止，什么时候停止是无法预知的。

因此，-9是比较粗暴的停止进程的方式，-TERM比较温和，但是，如果用-TERM停止进程，需要为进程的停止时间设置一个上限，否则，进程的停止时间是无法预知的，会造成一些无法估计的错误。

---

### 2016年8月26日

#### 3 grep的返回值的意义

使用grep在目录中查找某个模式，并将结果重定向到另一个文件中，然后对结果进行处理。一直以为，返回的状态表示命令运行的状态：命令运行成功，$?=0；命令运行失败，$?!=0。

但是，当结果为空时，xargs grep返回123，命令执行成功，只是没有结果，但是，命令返回状态码是123。

查看了grep返回码表示的含义：0表示结果不为空，1表示结果为空，2表示出错。因此，当执行grep没有结果时，grep返回的状态码是1。

再看xargs的状态码：当后面执行的命令的状态码是1-125时，返回123。

---

### 2016年9月14日

#### 4 变量的二次替换(eval)

文件中包含的内容是`hello $name`(文件名是a.txt)，shell脚本的内容如下：

```shell
#!/bin/bash
name=world

while read line
do
    echo $line
done < a.txt
```

脚本的输出是`hello $name`。但是，由于在脚本中设置了变量的值，因此，希望输出的内容是`hello world`。

这时候，就该eval派上用场了。`eval command`会先对command进行一次扫描，将其中的变量进行替换，然后再执行命令。这里，将`echo $line`改为`eval echo $line`就可以实现想要的功能。在执行时，会先将`echo $line`中的line替换为内容，即变成`echo hello $name`，然后再执行时，就会将name变量替换成实际的值了。

另外，在读取时，应该将line的赋值理解为单引号赋值：`line='hello $name'`。如果理解成双引号赋值，那么line变量的值就已经是替换过的。因此，这里要理解为单引号赋值。