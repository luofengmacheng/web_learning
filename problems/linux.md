### 2016年8月23日

#### 1 使用xargs操作多个文件时，结果的格式问题

使用正则表达式在目录中查找某个模式，采用了xargs grep进行，得到的结果类似如下：

```
file1:matched_text
file2:matched_text
```

然后，使用程序对该结果进行分析，得到每个文件中的所有的匹配模式。

然而，当文件只有一个时，却有问题，得到的结果却是：

```
matched_text
```

对多个文件操作时，结果中带了匹配的文本所在的文件，而对单个文件操作时，却没有携带文件名。

是什么造成了这种差异呢？是xargs还是grep本身呢？

xargs只是依次用后面的命令处理输入的参数，因此，这种结果应该是grep本身产生的。通过对grep的帮助文档的查看，找到了对应的说明：

> -H, --with-filename
> Print the file name for each match. This is the default when there is more than one file to search
> -h, --no-filename
> Suppress the prefixing of file names on output. This is the default when there is only one file (or only standard input) to search

grep的默认行为是：当操作的文件只有一个时，结果中不包含文件名；当操作的文件不止一个，对每个匹配添加文件名。

因此，给grep命令添加`-H`选项可以解决该问题。

---

### 2016年8月25日

#### 2 kill发送信号时，TERM和KILL的区别

在脚本中调用另一个停止进程的脚本，结果超时了(超时时间为10分钟)。手动执行脚本，很快就正常结束了。

然后，阅读停止进程的脚本，发现它采用如下的方式停止脚本：

* 查看PID文件是否存在，如果存在，则直接读取PID，如果不存在，则根据执行进程的命令获取PID。
* 给进程发送TERM信号
* 然后循环等待进程退出，每过1秒查看进程是否存活，直到进程退出为止。

但是，之前在脚本中调用该停止脚本时超时，也许这里会产生死循环？

然后再次手动执行，结果这次没有正常结束，也就是说，脚本的执行存在一定的概率性。

发现让进程停止的命令是`kill -TERM $pid`，而我们常用的进程停止命令是`kill -9 $pid`，TERM与9是什么关系呢？



---

### 2016年8月26日

#### 3 grep的返回值的意义

使用grep在目录中查找某个模式，并将结果重定向到另一个文件中，然后对结果进行处理。一直以为，返回的状态表示命令运行的状态：命令运行成功，$?=0；命令运行失败，$?!=0。

但是，当结果为空时，xargs grep返回123，命令执行成功，只是没有结果，但是，命令返回状态码是123。

查看了grep返回码表示的含义：0表示结果不为空，1表示结果为空，2表示出错。因此，当执行grep没有结果时，grep返回的状态码是1。

再看xargs的状态码：当后面执行的命令的状态码是1-125时，返回123。